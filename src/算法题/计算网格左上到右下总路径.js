/**
 * @desc
 *  题目：给定一个 m × n 网格，左上角起点标记为 Start，每次移动一步，求走到右下角 Finish 总共有多少条不同的路径？
 *    - 注意：每次的移动方向只能向右或向下
 *  分析：
 *    这道题给人的感觉就是动态规划，想要到达最右下角的那个位置，只有两种方法，
 *    一是从右下角位置的上面位置往下移动一次，
 *    二是从右下角位置的左边位置往右移动一次，
 *    那么，我们假设移动到右下角的路径为：f(m, n)，则 f(m, n) = f(m - 1, n) + f(m, n -1)，
 *    任何动态规划都有个起始条件，在这个问题中，起始条件是：
 *      - f(0, 0) === 1 起点到起点只有一种方式，甚至不用啥方式
 *      - f(0, n) === 1 在第一行，每个位置只能从左边移动过来，因此初始化这些位置为 1
 *      - f(m, 0) === 1 在第一列，每个位置只能从上面移动过来，因此初始化这些位置为 1
 *    注意上面的 m, n 是行列的索引表示，不是行列的数量
 */

// 递归（时间复杂度和空间复杂度都不好）
// 0 行或 0 列代表没有，1 行或 1 列只有一种方式
function path1(m, n) {
  if (m === 0 || n === 0) return 0
  if (m === 1 || n === 1) return 1
  return path1(m - 1, n) + path1(m, n - 1)
}

// 使用二维数组缓存（空间复杂度还是不太好）
// 构建网格，网格中的数字代表从左上角到此位置的总路径数
// 先把初始值预设好，然后依次计算每个网格的数字
// 右下角位置的索引是 [m - 1][n - 1]
function path2(m, n) {
  if (m === 0 || n === 0) return 0
  const arr = Array.from({ length: m }, () => new Array(n).fill(0))

  for (let i = 0; i < n; i++) arr[0][i] = 1
  for (let j = 0; j < m; j++) arr[j][0] = 1

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      arr[i][j] = arr[i - 1][j] + arr[i][j - 1]
    }
  }

  return arr[m - 1][n - 1]
}

// 使用一维数组缓存（时间和空间都可以，推荐！）
// 初始化第一行的值，其中第一列网格的值也是每一行第一列网格的值，都是 1，不会变的
// 从第二行第二列的位置开始，逐行遍历，位置数字 = 上一行相同位置的数字 + 左边位置的数字
// 遍历完成后，数组的最后一位数就是右下角位置的数字
function path3(m, n) {
  if (m === 0 || n === 0) return 0
  const arr = new Array(n).fill(1)
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      arr[j] = arr[j] + arr[j - 1]
    }
  }
  return arr[n - 1]
}

/**
 * 测试代码
 */

console.log(path1(0, 0), path1(1, 1), path1(3, 2), path1(3, 7))
console.log(path2(0, 0), path1(1, 1), path1(3, 2), path1(3, 7))
console.log(path3(0, 0), path1(1, 1), path1(3, 2), path1(3, 7))

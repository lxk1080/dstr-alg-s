/**
 * @desc 获取任意数字之前的所有回文数
 *  三个思路：
 *    1. 遍历数字，将数字转为字符串，分割成数组，然后 reverse，判断是否与反转前相等（常规思路）
 *    2. 遍历数字，将数字转为字符串，使用双指针，头尾各有一个指针，都向中间靠拢，判断字符是否相等，当两个指针重叠时结束（优化做法）
 *    3. 遍历数字，翻转数字，纯数字运算，不用字符串，要记住这个翻转公式（数学解法）
 *        - 这个要是仔细想想也简单
 *        - 因为要拿到最后一个数，肯定要除以 10 并取余
 *        - 要拿到倒数第二个数，需要把最后一个数去掉，然后用上面的方法取余，那去掉最后一个数，就是除以 10 取整
 *        - 然后把取出来的第一个数和第二个数拼接，在数字层面，需要把第一个数乘以 10 然后加上第二个数
 *        - 直到除以 10 取整后为 0 结束，因为 0 除以 10 的余数还是 0，后面再计算就没意义了
 */

function palindromic(max) {
  const res = []
  for (let i = 0; i < max; i++) {
    let n = i
    let rev = 0

    while (n > 0) {
      rev = rev * 10 + n % 10 // 主要是这一句能取到最终值，把拿到的数字进行一一拼接（通过数字运算的方式拼接）
      n = Math.floor(n / 10) // 这一句主要是去掉已经拿到的数字，得到剩余的数字
    }

    if (rev === i) {
      res.push(i)
    }
  }
  return res
}

/**
 * 测试代码
 *  - 可单元测试
 */

console.log(palindromic(200))
console.log(palindromic(0))
